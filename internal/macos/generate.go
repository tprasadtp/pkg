// SPDX-FileCopyrightText: Copyright 2024 Prasad Tengse
// SPDX-License-Identifier: MIT

//go:build ignore

// Generates trampolines from CoreFoundation and SecurityFramework APIs.
package main

import (
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"os"
	"os/signal"
	"path/filepath"
	"strings"
	"syscall"
	"text/template"
)

type config struct {
	LibraryName      string `json:"LibraryName"`
	LibraryPath      string `json:"LibraryPath,omitempty"`
	LibraryFunction  string `json:"LibraryFunction"`
	TrampolinePrefix string `json:"TrampolinePrefix"`
	TrampolineName   string `json:"TrampolineName"`
}

const (
	coreFoundationPath    = "/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation"
	securityFrameworkPath = "/System/Library/Frameworks/Security.framework/Versions/A/Security"
	libSystemPath         = "/usr/lib/libSystem.B.dylib"
)

const assemblyTemplate = `// SPDX-FileCopyrightText: Copyright 2024 Prasad Tengse
// SPDX-License-Identifier: MIT
//
// This file is automatically generated by go run generate.go {{GenerateCommand}}
// DO NOT EDIT THIS FILE.

//go:build darwin

#include "textflag.h"
{{ range . }}
GLOBL	·{{.TrampolinePrefix}}_trampoline_{{.TrampolineName}}_addr(SB), RODATA, $8
DATA	·{{.TrampolinePrefix}}_trampoline_{{.TrampolineName}}_addr(SB)/8, ${{.TrampolinePrefix}}_trampoline_{{.TrampolineName}}<>(SB)
TEXT    {{.TrampolinePrefix}}_trampoline_{{.TrampolineName}}<>(SB),NOSPLIT,$0-0
	        JMP	{{.LibraryName}}_{{.LibraryFunction}}(SB)
            RET
{{end}}
`

const goTemplate = `// SPDX-FileCopyrightText: Copyright 2024 Prasad Tengse
// SPDX-License-Identifier: MIT
//
// This file is automatically generated by go run generate.go {{GenerateCommand}}
// DO NOT EDIT THIS FILE.

//go:build darwin

package macos
{{ range . }}
//go:cgo_import_dynamic {{.LibraryName}}_{{.LibraryFunction}} {{.LibraryFunction}} "{{.LibraryPath}}"
//nolint:revive,stylecheck // ignore
var {{.TrampolinePrefix}}_trampoline_{{.TrampolineName}}_addr uintptr
{{end}}
`

var output string
var configFile string

func main() {
	flag.StringVar(&output, "output", "", "output directory")
	flag.StringVar(&configFile, "config", "generate.json", "config file")
	flag.Parse()

	ctx, _ := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
	err := generate(ctx)
	if err != nil {
		log.Fatalf("Error: %s", err)
	}
}

func generate(ctx context.Context) error {
	if output == "" {
		return fmt.Errorf("output directory is not defined")
	}

	if err := ctx.Err(); err != nil {
		return err
	}

	log.Printf("checking config %s", configFile)
	if stat, err := os.Stat(configFile); err != nil {
		return fmt.Errorf("failed to stat config file: %w", err)
	} else if stat.Size() > 1e6 {
		return fmt.Errorf("config file is too large")
	}

	log.Printf("reading config file: %s", configFile)
	contents, err := os.ReadFile(configFile)
	if err != nil {
		return fmt.Errorf("failed to read config file: %w", err)
	}

	log.Printf("parsing config %s", configFile)
	c := []*config{}
	err = json.Unmarshal(contents, &c)
	if err != nil {
		return fmt.Errorf("failed to Unmarshal config: %w", err)
	}

	// Ensure library path is known.
	for _, item := range c {
		if item.LibraryPath == "" {
			switch item.LibraryName {
			case "CoreFoundation":
				item.LibraryPath = coreFoundationPath
			case "Security", "SecurityFramework":
				item.LibraryPath = securityFrameworkPath
			case "libc", "libSystem", "System", "LibSystem":
				item.LibraryPath = libSystemPath
			default:
				return fmt.Errorf("unknown library: %w", err)
			}
		}
	}

	err = render(c, "assembly", filepath.Join(output, "zz_generated.s"), assemblyTemplate)
	if err != nil {
		return err
	}

	err = render(c, "go", filepath.Join(output, "zz_generated.go"), goTemplate)
	if err != nil {
		return err
	}

	return nil
}

func render(c []*config, name string, out string, tpl string) error {
	log.Printf("generating %s", name)
	funcMap := template.FuncMap{
		"GenerateCommand": func() string {
			return strings.Join(os.Args[1:], " ")
		},
	}
	tasm, err := template.New(name).Funcs(funcMap).Parse(tpl)
	if err != nil {
		return fmt.Errorf("%s template is invalid: %w", name, err)
	}
	file, err := os.OpenFile(
		out,
		os.O_CREATE|os.O_TRUNC|os.O_WRONLY,
		0o644,
	)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer file.Close()

	err = tasm.Execute(file, c)
	if err != nil {
		return fmt.Errorf("failed to render %s template: %w", name, err)
	}
	return nil
}
